package readzip;

import java.io.ByteArrayOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FSDataInputStream;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.BytesWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.InputSplit;
import org.apache.hadoop.mapreduce.RecordReader;
import org.apache.hadoop.mapreduce.TaskAttemptContext;
import org.apache.hadoop.mapreduce.lib.input.FileSplit;

public class ReadZipRecordReader extends RecordReader<Text, BytesWritable>{
	
	private FSDataInputStream fsInputStream;
	private ZipInputStream zipInputStream;
	
	/*file key and content*/
	private Text currentKey;
	private BytesWritable currentValue;
	
	/*zipfilename*/
	private String zipFileName = null;
	
	private boolean isFinished = false;
	

	@Override
	public void close() throws IOException {
		//close all opened input streams
		zipInputStream.close();
		fsInputStream.close();
		
	}

	@Override
	public Text getCurrentKey() throws IOException, InterruptedException {
		
		return currentKey; 
	}

	@Override
	public BytesWritable getCurrentValue() throws IOException, InterruptedException {
		
		return currentValue;
	}

	@Override
	public float getProgress() throws IOException, InterruptedException {
		
		return isFinished ? 1f : 0f;
	}

	@Override
	public void initialize(InputSplit inputSplit, TaskAttemptContext taskAttemptContext) throws IOException, InterruptedException {
		FileSplit split = (FileSplit)inputSplit;
		Configuration conf = taskAttemptContext.getConfiguration();
		Path path = split.getPath();
		FileSystem fs = path.getFileSystem(conf);
		
		//At this point, fs has the absolute path info (on DFS) of our file
		fsInputStream = fs.open(path);
		//Converting our file as ZipInputStream object
		zipInputStream = new ZipInputStream(fsInputStream);
		
		zipFileName = path.getName();
		
	}

	@Override
	public boolean nextKeyValue() throws IOException, InterruptedException, NullPointerException {
		//ZipEntry is an extracted 'object' from the zip container
		ZipEntry entry = null;
		//isFinished = false;
		
		try{
			//entry will receive each extracted file from the zip container
			entry = zipInputStream.getNextEntry();
		}
		catch(ZipException e)
		{
			//TODO we can bypass this Exception if we get many errors at this point
			return false;
			
		}
		
		//Is there more data in our entry?
		if(entry == null) 
		{
			isFinished = true;
			return false;
		}
		
		//get the (extracted) filename
		currentKey = new Text(zipFileName + "-" + entry.getName());
		
		/*******DEBUG*********************************************/
		//Log log = LogFactory.getLog(ReadZipRecordReader.class);
		//log.info("------> key:  " + currentKey.toString());
		/*****************************************************************/
		
		
		//Read the content
		ByteArrayOutputStream byteArrayOutStream = new ByteArrayOutputStream();
		byte[] tmpByteArray = new byte[8192];
		
		//zipInputStream -> byteArray -> outputStream
		while(true)
		{
			int totalBytesRead = 0;
			try
			{
				//reads the content of a (extracted) file and put it on our byte array
				totalBytesRead = zipInputStream.read(tmpByteArray, 0, 8192);
			}
			catch(EOFException e)
			{
				//TODO we can bypass this Exception if we get many errors
				return false;
			}
			
			if(totalBytesRead > 0)
			{
				//writes (appending) the content of our byte array to our output Stream
				byteArrayOutStream.write(tmpByteArray, 0, totalBytesRead);
			}
			//there is no more data on the file to be read
			else 
				break;
		}
		
		zipInputStream.closeEntry();
		
		//finally we store the content of the (extracted) file in our mapper value (binary content)
		currentValue = new BytesWritable(byteArrayOutStream.toByteArray());
		
		//yes, we have a new (just calculated) key
		return true;
		
	}

}
